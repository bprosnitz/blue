part of vdl;

/// VdlBase is the base representation of values defined in VDL.
/// it is used to reduce duplicate code for common categories of types
/// Unlike VdlValue, VdlBase is subclassed; VdlValue represents generic values
/// while these are helpers used by the generated classes.
abstract class VdlBase {
  const VdlBase();
}

/// VdlBool represents bool classes generated by the vdl tool.
abstract class VdlBool extends VdlBase {
  final bool value;

  const VdlBool.zero() : this(false);
  const VdlBool(this.value);

  String toString() => value.toString();
  bool operator ==(Object o) => identical(this, o) ||
    (o is VdlBool && this.value == o.value);
  int get hashCode => value.hashCode;
}

/// VdlByte represents byte classes generated by the vdl tool.
abstract class VdlByte extends VdlBase {
  final int value;

  const VdlByte.zero() : this(0);
  const VdlByte(this.value);

  String toString() => value.toString();
  bool operator ==(Object o) => identical(this, o) ||
    (o is VdlByte && this.value == o.value);
  int get hashCode => value.hashCode;
}

/// VdlUint represents uint classes generated by the vdl tool.
abstract class VdlUint extends VdlBase {
  final int value;

  const VdlUint.zero() : this(0);
  const VdlUint(this.value);

  String toString() => value.toString();
  bool operator ==(Object o) => identical(this, o) ||
    (o is VdlUint && this.value == o.value);
  int get hashCode => value.hashCode;
}

/// VdlInt represents int classes generated by the vdl tool.
abstract class VdlInt extends VdlBase {
  final int value;

  const VdlInt.zero() : this(0);
  const VdlInt(this.value);

  String toString() => value.toString();
  bool operator ==(Object o) => identical(this, o) ||
    (o is VdlInt && this.value == o.value);
  int get hashCode => value.hashCode;
}

/// VdlFloat represents float classes generated by the vdl tool.
abstract class VdlFloat extends VdlBase {
  final double value;

  const VdlFloat.zero() : this(0.0);
  const VdlFloat(this.value);

  String toString() => value.toString();
  bool operator ==(Object o) => identical(this, o) ||
    (o is VdlFloat && this.value == o.value);
  int get hashCode => value.hashCode;
}

/// VdlComplex represents complex classes generated by the vdl tool.
/// Unlike other primitive, classes, VdlComplex will also represent the unnamed
/// complex value since Dart does not have a native representation for complex.
class VdlComplex extends VdlBase {
  static final VdlType vdlType = VdlTypes.Complex128;

  // These fields are not final, but that will prevent us from creating complex
  // constants.
  double real;
  double imag;

  VdlComplex.zero() : this(0.0, 0.0);
  VdlComplex(this.real, this.imag);

  String toString() => imag < 0 ? "${real}${imag}i" : "${real}+${imag}i";
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is VdlComplex && other.real == this.real && other.imag == this.imag) {
      return true;
    }
    return false;
  }
  int get hashCode => quiver_core.hash2(real, imag);
}

/// VdlString represents named string classes generated by the vdl tool.
abstract class VdlString extends VdlBase {
  final String value;

  const VdlString.zero() : this('');
  const VdlString(this.value);

  String toString() => value;
  bool operator ==(Object o) => identical(this, o) ||
    (o is VdlString && this.value == o.value);
  int get hashCode => value.hashCode;
}

/// VdlList<T> represents generic list classes generated by the vdl tool.
abstract class VdlList<T> extends VdlBase with ListMixin<T> {
  final List<T> _data;

  VdlList(this._data);
  VdlList.zero() : this(new List<T>());
  // TODO(alexfandrianto): More constructors.

  void set length(int newLength) {
    _data.length = newLength;
  }
  int get length => _data.length;
  T operator [](int index) => _data[index];
  void operator []=(int index, T value) {
    _data[index] = value;
  }

  String toString() => _data.toString();
}

/// VdlArray<T> represents generic array classes generated by the vdl tool.
abstract class VdlArray<T> extends VdlBase with ListMixin<T> {
  final List<T> _data;

  VdlArray(this._data) {}
  // Note: This must be overriden. Types are static+final, so this has not been
  // implemented with the "length" restriction.
  VdlArray.zero() : this(new List<T>());
  // TODO(alexfandrianto): More constructors.

  void set length(int newLength) {
    throw new UnsupportedError('VdlArray does not support setting length.');
  }
  int get length => _data.length;
  T operator [](int index) => _data[index];
  void operator []=(int index, T value) {
    _data[index] = value;
  }

  String toString() => _data.toString();
}

/// VdlSet<T> represents generic set classes generated by the vdl tool.
abstract class VdlSet<K> extends VdlBase with SetMixin<K> {
  final Set<K> _data;

  VdlSet(this._data);
  VdlSet.zero() : this(new Set<K>());

  bool add(K e) => _data.add(e);
  get length => _data.length;
  Set<K> toSet() => _data.toSet();
  List<K> toList({bool growable: true}) => _data.toList(growable: growable);
  bool remove(Object element) => _data.remove(element);
  bool contains(Object element) => _data.contains(element);
  K lookup(K element) => _data.lookup(element);
  Iterator<K> get iterator => _data.iterator;

  String toString() => _data.toString();
}

/// VdlMap<T> represents generic map classes generated by the vdl tool.
abstract class VdlMap<K, V> extends VdlBase with MapMixin<K, V> {
  final Map<K, V> _data;

  VdlMap(this._data);
  VdlMap.zero() : this(new Map<K, V>());

  V operator [](K key) => _data[key];
  void operator []=(K key, V value) {
    _data[key] = value;
  }
  void clear() => _data.clear();
  V remove(Object element) => _data.remove(element);
  Iterable<K> get keys => _data.keys;

  String toString() => _data.toString();
}

/// VdlOptional<T> represents optional classes. Unlike other VdlBase subclasses,
/// this is not generated by the vdl tool, so it is not abstract. VdlOptional<T>
/// is used directly in generated VDL code. Reflection is used to determine the
/// correct VdlType by inspecting T.
class VdlOptional<T> extends VdlBase {
  final T elem;

  VdlOptional(this.elem);
  VdlOptional.zero() : this(null);

  String toString() => elem.toString();
  bool operator ==(Object o) => identical(this, o) ||
    (o is VdlOptional && this.elem == o.elem);
  int get hashCode => elem == null ? 0 : elem.hashCode;
}

/// VdlStruct represents struct classes generated by the vdl tool.
/// Unlike other VdlBase subclasses the fields are not known beforehand, so much
/// of the implementation will be autogenerated.
abstract class VdlStruct extends VdlBase {}

/// VdlUnion represents union classes generated by the vdl tool.
/// Unlike other VdlBase subclasses the fields are not known beforehand, so much
/// of the implementation will be autogenerated.
abstract class VdlUnion extends VdlBase {}

/// VdlEnum represents enum classes generated by the vdl tool.
abstract class VdlEnum extends VdlBase {
  final String className;
  final String label;
  final int ordinal;
  const VdlEnum(this.className, this.label, this.ordinal);

  bool operator ==(Object other) => identical(this, other) || (other is VdlEnum && other.label == this.label);
  int get hashCode => label.hashCode;
  String toString() => '${className}.${label}';
}